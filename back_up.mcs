--local module_vrp 	= AddModule("main","Solve VRP")

--local prm_vrp 		= AddParameter(module_vrp, nil, "node", "Disruption Parameters")
--CONSTRUCTIVES       = AddParameter(module_vrp, prm_vrp, "choice", "Constructive Algorithms", "ad hoc|Nearest Neighbor|Clarke Wright|Sweep", 1)
--SEQUENCES           = AddParameter(module_vrp, prm_vrp, "choice", "Sequece based Algorithms", "None|SA|GRASP|TS|VNS|ILS", 1)
----SETS                = AddParameter(module_vrp, prm_vrp, "choice", "Set based Algorithms", "None|GA|MA|ACO", 1)
--local display_vrp       = AddParameter(module_vrp, nil, "node", "Date Parameters")
--CONSOLEDISPLAY          = AddParameter(module_vrp, display_vrp, "check", "Is console output?", true)
--FIGUREDISPLAY           = AddParameter(module_vrp, display_vrp, "check", "Is figure output?", true) 
--FILEDISPLAY             = AddParameter(module_vrp, display_vrp, "check", "Is file output?", false)


--routesNum = 3
--SMD1_0 = {}
--for i=1,#nodes do
--    SMD1_0[i] = {}
--    for j=1,#node+routesNum do
        
    
--    end 
--end

--local function creatRoute(node)
--    local route_id = -giant:getRouteNum()-1
--    nodes[route_id] = DeepCopy(nodes[0])
--    nodes[route_id].suc = node
--    nodes[node].pre = route_id 
--    nodes[node].suc = -1
--    nodes[-1].pre = node
--    nodes[node].route = 
--end 

--function back_forth()
--    local r = -1
--    for i=1,#nodes do
--        nodes[i].pre = r
--        nodes[i].suc = r-1
--        r = r + 1
--        markForward(i)
--        markBackward(i)
--    end 
--    nodes[#nodes].suc = -1
--end 

--Class Name: Solution
--Meaning: The abstraction of routes result
--Attributes: cost, penaCost, feasible, routes
--Methods: getCost(), isFeasible(), appendRoute(), clone(), sort(), executeMove(),

Solution = {cost = false, pena_cost = false, feasible = true}
Solution.__index = Solution

function Solution:new()
    local self = {}
    setmetatable(self, Solution)
    self.cost = false
    self.pena_cost = false
    self.feasible = true
    return self
end 



local function copyKeyValue(toTab, fromTab)    
    for key,value in pairs(fromTab) do
        toTab[key] = value
    end 
end




function Solution:convert2Giant()
    for r,route in ipairs(self) do
        nodes[-r] = {suc=route[1].id, route=-r, vtp=route.vtp}
        copyKeyValue(nodes[-r], nodes[0])
        copyKeyValue(nodes[-r], route[0])
        
        if #route > 1 then 
            nodes[route[1].id].pre, nodes[route[1].id].suc = -r, route[2].id
            for i=2,#route-1 do nodes[route[i].id].pre, nodes[route[i].id].suc = route[i-1].id, route[i+1].id end 
            nodes[route[#route].id].pre, nodes[route[#route].id].suc = route[#route-1].id, -r - 1
        else
            nodes[route[1].id].pre, nodes[route[1].id].suc = -r, -r - 1
        end 
    
        for i=1,#route do 
            copyKeyValue(nodes[route[i].id], route[i])
            nodes[route[i].id].route, nodes[route[i].id].vtp = -r, route.vtp
        end 
    end 
    nodes[self[#self][#self[#self]].id].suc = -1
    for i=2,#solution do
        nodes[-i].pre = self[i-1][#self[i-1]].id
    end 
    nodes[-1].pre = self[#self][#self[#self]].id
end 

function Solution:getCost()
    local cost = 0
    local total_distance = 0
    for r,route in ipairs(self) do
        for i=1,#route do
            if route[i].bT > nodes[route[i].id].time2 then 
                self.isfeasible = false
                self.cost = math.huge 
                return self.cost
            end
            cost = cost + dis(route[i-1].id,route[i].id) * vehicle[route.vtp].tc + math.max(0,  nodes[route[i].id].time1 - route[i].bT) * vehicle[route.vtp].wc
            total_distance = total_distance +  dis(route[i-1].id,route[i].id)
        end 
        cost = cost +  vehicle[route.vtp].fc + dis(route[#route].id,0) * vehicle[route.vtp].tc
        total_distance = total_distance +  dis(route[#route].id,0)
    end 
    print('Total distance: ', total_distance)
    self.cost = cost
    return self.cost
end 

function Solution:appendRoute(route)
    table.insert(self, route)
end 

function Solution:clone()
    return DeepCopy(self)
end 
-----???---
function Solution:sort()
    table.sort(self, function(a,b) return #a<#b end)
end 

function Solution:executeMove(Move)
    local route1 = self[Move[1].r]
    if Move[1].r==Move[2].r then 
        if Move.mtp==0 then
            for a=1, math.floor((Move[2].p-Move[1].p)/2) do
                route1[Move[1].p+a], route1[Move[2].p+1-a] = route1[Move[2].p+1-a], route1[Move[1].p+a]
            end 
            for a=Move[1].p+1,Move[2].p do
                forward_mark(route1, a)
            end 
            for a=Move[2].p,Move[1].p+1,-1 do
                backward_mark(route1, a)
            end 
        elseif Move.mtp==1 then
            table.insert(route1,  Move[2].p + 1, route1[Move[1].p])
            table.remove(route1,  Move[1].p)
            forward_mark(route1,  math.min(Move[2].p + 1, Move[1].p))
            backward_mark(route1, math.max(Move[2].p + 1, Move[1].p))
        end 
    else
        local route2 = Move[2] and self[Move[2].r] or nil
        if Move.mtp==0 then
            for a=1,math.max(#route1-Move[1].p,#route2-Move[2].p) do
                route1[Move[1].p + a], route2[Move[2].p + a] = route2[Move[2].p + a], route1[Move[1].p + a]
            end 
            if #route1==0 then 
                table.remove(self, Move[1].r)
            else
                forward_mark(route1, Move[1].p + 1)
                backward_mark(route1, Move[1].p)
            end 
            if #route2==0 then 
                table.remove(self, Move[2].r)
            else
                forward_mark(route2, Move[2].p + 1)
                backward_mark(route2, Move[2].p)
            end 
        elseif Move.mtp==1 then
            table.insert(route2, Move[2].p + 1, route1[Move[1].p])
            forward_mark(route2, Move[2].p + 1)
            backward_mark(route2, Move[2].p + 1)
            if #route1==1 then 
                table.remove(self, Move[1].r)
            else
                table.remove(route1, Move[1].p)
                forward_mark(route1, Move[1].p)
                backward_mark(route1, Move[1].p - 1)
            end 
        elseif Move.mtp==2 then
            route1[i], route2[j] = route2[j], route1[i]
        end     
    end 
--    if Move.delta<0 then 
--        print('The solution has been imporved: ', Move.delta)
--    else 
--        print('The solution be deteriorated temporary: ', Move.delta)
--    end 
end 

function Solution:output()
    io.output(#solution .. '+'.. solution:getCost() .. 'Result.csv')
    io.write('trans_code   ,  vehicle type , visit count , total weight, loading wegiht, total volume,  loading volume,  origin, customer id-arrival time\n')
    for i=1,#self do
        io.write(string.format('DP%04d, %d, %d,', i, self[i].v_type, #self[i]))
        io.write(string.format('%d,', vehicle[self[i].v_type].weight))
        io.write(string.format('%f,', self[i][1].bW))
        io.write(string.format('%d,', vehicle[self[i].v_type].volume))
        io.write(string.format('%f,', self[i][1].bV))
        --local totalDistance = 0        
        for j=0,#self[i] do
            if j<#self[i] then
                io.write(string.format('%d-%02d:%02d,', self[i][j].id, math.floor(self[i][j].bT/60), self[i][j].bT%60))
            else 
                io.write(string.format('%d-%02d:%02d', self[i][j].id, math.floor(self[i][j].bT/60),self[i][j].bT%60 ))
            end
        end
        io.write('\n')
        io.write(string.format('time window, , , ,  %f%%, , %f%%,', self[i][1].bW/vehicle[self[i].v_type].weight*100, self[i][1].bV/vehicle[self[i].v_type].volume*100))    
        for j=0,#self[i] do
            if j<#self[i] then
                io.write(string.format('%02d:%02d-%02d:%02d,', math.floor(nodes[self[i][j].id].time1/60),nodes[self[i][j].id].time1%60, math.floor(nodes[self[i][j].id].time2/60), nodes[self[i][j].id].time2%60))
            else 
                io.write(string.format('%02d:%02d-%02d:%02d', math.floor(nodes[self[i][j].id].time1/60),nodes[self[i][j].id].time1%60, math.floor(nodes[self[i][j].id].time2/60), nodes[self[i][j].id].time2%60))
            end
        end
        io.write('\n')
    end
    
    io.close()
end 

function Solution:plot()
    if not Nodes then 
        Nodes = CreateShapes('nodes [Points]','point') 
        AddField(Nodes, 'id', 'int')
        AddField(Nodes, 'ptype', 'int') -- dont do that:the color of attributes put at first place
        AddField(Nodes, 'weight', 'float')
        AddField(Nodes, 'volume', 'float')
        AddField(Nodes, 'route', 'int')
        AddField(Nodes, 'TW', 'string')
        for i=0,#nodes do
            local shp = AddShape(Nodes, nodes[i].x, nodes[i].y) 
            SetValue(shp, i==0 and 0 or 1, 'ptype')
            SetValue(shp, i, 'id')
            SetValue(shp, nodes[i].weight, 'weight')
            SetValue(shp, nodes[i].weight, 'volume')
            SetValue(shp, '[' .. nodes[i].time1 .. ',' .. nodes[i].time2 .. ']', 'TW')
        end
        Update(Nodes)
        SetParameter(Nodes, "COLORS_TYPE", 3)
        SetParameter(Nodes, "LABEL_ATTRIB", 1)
    end 
    SetValue(Nodes, 0, 'route', 1) 
    local Routes = CreateShapes('Solution [Lines]','line')
    AddField(Routes, 'id', 'int')
    AddField(Routes, 'route_segment', 'int')  --  dont do that: the color of attributes put at first place
    AddField(Routes, 'route_travel_time', 'float')
    for i, route in ipairs(self) do
        for j=0,#route-1 do 
            local shp = AddShape(Routes, nodes[route[j].id].x,nodes[route[j].id].y,nodes[route[j+1].id].x,nodes[route[j+1].id].y)
            SetValue(shp, i, 'id')
            SetValue(shp, j, 'route_segment')
            if j>0 then
                SetValue(Nodes, route[j].id+1, 'route', route[#route].id) 
            end 
        end
    end 
    SetParameter(Routes, "COLORS_TYPE", 3)
    Update(Routes)
    CreateView('vrp result cost: ' .. self:getCost(), Nodes, Routes)
end


local function isVisitAllNodesOnce(cSolu)
    local count = {}
    for i=1,#cSolu do
        for j=1,#cSolu[i] do
            count[cSolu[i][j].id] = count[cSolu[i][j].id] and count[cSolu[i][j].id]+1 or 1
        end 
    end
    for i=1,#nodes do
        if not count[i] then 
            print('node',i, 'not be visited')
            return false
        elseif count[i] > 1 then
            print('node',i, 'visit ',count[i])
            return false
        end  
    end 
    return true
end 

local function checkRoute(cRoute)
    local cumWeight, cumVolume, t = 0, 0, 0
    for i=0,#cRoute-1 do
        cumWeight = cumWeight + nodes[cRoute[i].id].weight
        cumVolume = cumVolume + nodes[cRoute[i].id].volume
        if cumWeight>vehicle[cRoute.v_type].weight or cumVolume>vehicle[cRoute.v_type].volume then 
            print('dsdsfsfsd')
            return false 
        end
        t = t + time[cRoute[i].id][cRoute[i+1].id] + nodes[cRoute[i].id].stime 
        if t > nodes[cRoute[i+1].id].time2 then return false end 
        t = math.max(t, nodes[cRoute[i+1].id].time1)
    end 
    if not OPEN then 
        if t + time[cRoute[#cRoute].id][0] + nodes[cRoute[#cRoute].id].stime >= nodes[0].time2 then 
            return false
        end 
    end 
    for i=1,#cRoute do
        if cRoute[i].bT>nodes[cRoute[i].id].time2 then
            return false
        end 
    end 
    return true
end 


function Solution:isFeasible()
    if not isVisitAllNodesOnce(self) then 
        self.feasible = false
        return false 
    end 
    for r,route in ipairs(self) do
        if not checkRoute(route) then 
            return false
        end 
    end 
    return 'Congratulations!!!'
end 