function init()
    require '01Class.Move'
    require '01Class.Delta'
    require '01Class.Feasible'
    require '01Class.Node&Giant'
    require '01Class.Route&Solution'
    require '02Module.BasicFunction'
    require '04CG.Subproblem'
    require '04CG.Master'
    require '04CG.Label'
    VRPIO = require '02Module.VRPIO'   
    Constructives = require '02Module.Constructives'
    Algorithms = require '02Module.Algorithms'
end 

init()
UpBound = math.huge
best_solution = {}
function columnGeneration(cRoutes, cForbids, vNumberCons)
    require 'mobdebug'.off()
    local iter, master = 0
    repeat
        iter = iter + 1
        master = Master:new(cRoutes, cForbids, vNumberCons)
        if master:solve() ~= 0 then return nil end 
        master:setNodesDual()
        cRoutes[#cRoutes+1], cRoutes[#cRoutes+2] = solveSubproblem(cForbids)
        print('the LP relax obj = ', master:getObj())
        print('The min reduced cost = ', cRoutes[#cRoutes].cost)
    until cRoutes[#cRoutes].cost > -0.01
    print('Total iteration = ', iter)
    require 'mobdebug'.on()
    return master
end

function branchNode(cRoutes, cForbids, vNumberCons)
    local master = columnGeneration(cRoutes, cForbids, vNumberCons)
    require 'mobdebug'.on()
    if master then
        if master:isInteger() then
            -- 如果最后直接是整数解，那很完美，不需要再分支
            UpBound = master:getObj() < UpBound and master:getObj() or UpBound
        elseif master:getObj() < UpBound then  -- 否则分支，加入binary约束后，解的值必然变差, 如果比上界还高或相等，那无可救药，停止分支
            local vehcile_number = master:getVarSum()
            local sss = {}
            for i,ir in ipairs(master:getResult()) do
                if ir > 0.00001 then 
                    table.insert(sss, master.routes[i])
                end 
            end 
            
            
            if vehcile_number % 1 > 0.0001  and (1 - vehcile_number % 1) > 0.0001 then 
                master:solve(true)
                UpBound = master:getObj() < UpBound and master:getObj() or UpBound
                branchNode(DeepCopy(cRoutes), cForbids, {math.floor(vehcile_number), '<='})
                branchNode(DeepCopy(cRoutes), cForbids, {math.ceil(vehcile_number) , '>='})
            else
                local arc = master:getBranchArc()
                
                master:solve(true)
                UpBound = master:getObj() < UpBound and master:getObj() or UpBound
                
                cForbids:append(Forbid:new(arc, 1))
                branchNode(master.routes, DeepCopy(cForbids), vNumberCons)
                
                cForbids[#cForbids].ok = 0
                branchNode(master.routes, DeepCopy(cForbids), vNumberCons)
            end 
        end 
          print(master:getObj())
    print(master:getVarSum())
    end
  
end 


function main()
    require 'mobdebug'.off()
    nodes, Dis, Time, vehicle = VRPIO.read_solomon('R106', 25)
    preprocessing()
    nodes[0].dual = 0
    
    local starttime = os.time()
    --master = columnGeneration(master.routes, Forbids:new(), {5, '<='})
    
    branchNode(Constructives.getBackForth(), Forbids:new())
    require 'mobdebug'.on()
    print(os.time()-starttime)
end 
main()