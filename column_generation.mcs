function init()
    require '01Class.Move'
    require '01Class.Delta'
    require '01Class.Feasible'
    require '01Class.Node&Giant'
    require '01Class.Route&Solution'
    require '02Module.BasicFunction'
    require '04CG.Subproblem'
    --require '04CG.Master'
    require '04CG.Label'
    require '04CG.Forbid'
    --require '04CG.BranchNode'
    VRPIO = require '02Module.VRPIO'   
    Constructives = require '02Module.Constructives'
    Algorithms = require '02Module.Algorithms'
end 

init()
UpBound = math.huge
BestVehicles = math.huge
best_solution = {}

Route = {vtp = 1}
Route.__index = Route

function Route:new(vtp, cost)
    local self = {vtp = vtp or 1, cost = cost}
    setmetatable(self, Route)
    self[0] = {id=0, fT = nodes[0].time1, bT=nodes[0].time2, fW = 0, fV = 0, bW=0, bV=0} 
    return self
end 

function Route:contains(node)
    for i=1,#self do
        if self[i].id == node then 
            return true
        end 
    end 
    return false
end 

function Route:getBranchArc(cRoute, cForbids)
    local function isIn(node1, node2)
        for _,forbid in ipairs(cForbids) do
            if node1 == forbid.arc[1] and node2 == forbid.arc[2] then
                return true
            end
        end 
    end 
    
    if not self:intersects(cRoute) then error(110) end 
    for i=1,#self do
        for j=1,#cRoute do
            if self[i].id == cRoute[j].id then 
                if self[i-1].id ~= cRoute[j-1].id then 
                    if not isIn(self[i-1].id, self[i].id) then 
                        return {self[i-1].id, self[i].id}
                    end 
                elseif i < #self then
                    if (j == #cRoute or self[i+1].id ~= cRoute[j+1].id) and not isIn(self[i].id, self[i+1].id) then
                        return {self[i].id, self[i+1].id}
                    end
                elseif j < #cRoute and not isIn(cRoute[j].id, cRoute[j+1].id) then 
                    return {cRoute[j].id, cRoute[j+1].id}
                end 
                goto continue
            end 
        end
        ::continue::
    end 
end 

function Route:intersects(cRoute)
    for i=1,#self do
        for j=1,#cRoute do
            if self[i].id == cRoute[j].id then
                return true
            end 
        end 
    end 
    return false
end 

function Route:forward_mark(p)
    for i=p,#self do
        self[i].fT = push_forward(self[i-1], self[i].id)
        self[i].fW = self[i-1].fW + nodes[self[i].id].weight
        self[i].fV = self[i-1].fV + nodes[self[i].id].volume
    end 
end 

function Route:backward_mark(p)
    for i=p,1,-1 do
        local point = self[i+1] or {id = 0, bT = nodes[0].time2, bW = 0, bV = 0}
        self[i].bT = push_backward(point, self[i].id)
        self[i].bW = point.bW + nodes[self[i].id].weight
        self[i].bV = point.bV + nodes[self[i].id].volume
    end
end 

function Route:push_back(node_id)
    local fT, bT, forward
    forward = self[#self]
    fT = push_forward(forward, node_id)
    bT = nodes[node_id].time2
    table.insert(self, {id=node_id, fT=fT, bT=bT, fW=forward.fW + nodes[node_id].weight, fV=forward.fV + nodes[node_id].volume, bW=nodes[node_id].weight, bV=nodes[node_id].volume})
    self:backward_mark(#self-1)
end 

function Route:append(point)
    self[#self+1] = DeepCopy(point)
end 

function Route:push_back_seq(seq)
    for i=1,#seq do
        local fT, bT, forward
        forward = self[#self]
        fT = push_forward(forward, seq[i].id)
        table.insert(self, {id=seq[i].id, fT=fT, bT=bT, fW=forward.fW + nodes[seq[i].id].weight, fV=forward.fV + nodes[seq[i].id].volume})
    end
    self[#self].bW = nodes[seq[#seq].id].weight
    self[#self].bV = nodes[seq[#seq].id].volume
    self[#self].bT = nodes[seq[#seq].id].time2
    self:backward_mark(#self-1)
end 

function Route:getCost()
    local cost = vehicle[self.vtp].fc
    for i=1,#self do
        cost = cost + dis(self[i-1].id, self[i].id) * vehicle[self.vtp].tc + math.max(0, nodes[self[i].id].time1 - self[i].bT) * vehicle[self.vtp].wc
    end
    return cost + dis(self[#self].id, 0) * vehicle[self.vtp].tc
end 

Master = {}
Master.__index = Master

local function resetCoeff(cSize, value)
    local coeff = {}
    for i=1,cSize do
        coeff[i] = value or 0
    end 
    return coeff
end 

function Master:new(cRoutes, cForbids, cvNum)
    local self = {obj = {}, routes = cRoutes, forbids = cForbids or {}, num = cvNum, carDual = 0}
    setmetatable(self, Master)
    self.lp = CreateLP()
    self:buildModel()
    if self.num then AddConstraint(self.lp, resetCoeff(#self.obj, 1), cvNum[2], cvNum[1]) end 
    return self
end 

function Master:setVehNum(compare, num)
    AddConstraint(self.lp, resetCoeff(#self.obj, 1), compare, num)
end 

function Master:buildModel()
    for i=1,#self.routes do
        self.obj[i] = self.routes[i]:getCost()
    end 
    SetObjFunction(self.lp, self.obj, 'min')
    
    for i=1,#nodes do
        local coeff = resetCoeff(#self.obj)
        for r,route in ipairs(self.routes) do
            if route:contains(i) then 
                coeff[r] = 1
            end 
        end
        AddConstraint(self.lp, coeff, '>=', 1)
    end
    
    for i=1,#nodes do
        local coeff = resetCoeff(#self.obj)
        coeff[i] = 1
        AddConstraint(self.lp, coeff, '<=',1)
    end
end 

function Master:solve(isInteger)
    if isInteger then
        for i=1,#self.obj do
            SetBinary(self.lp, i)
        end 
    end 
    return SolveLP(self.lp)
end 

function Master:getDuals()
    return {GetDuals(self.lp)}
end 

function Master:setNodesDual()
    local duals = self:getDuals()
    for i=1,#nodes do
        nodes[i].dual = duals[i]
    end 
    if #duals > #nodes then
        self.carDual = duals[#duals] 
    end 
end 

function Master:getObj()
    return GetObjective(self.lp)
end

function Master:getResult()
    return  {GetVariables(self.lp)}
end 

function Master:getMostFractional()
    if not self.result then self.result = self:getResult() end
    local choice = {}
    for i=1,#self.result do
        if self.result[i] < 0.99999 and self.result[i] > 0.0001 then
            table.insert(choice, {self.result[i], id = i})
        end 
    end 
    table.sort(choice, function(a,b) return a[1]>b[1] end)
    return choice
end

function Master:getBranchArc()   -- return arc {node1, node2}
    local choice = self:getMostFractional()
    for i=1,#choice do
        for j=i+1,#choice do
            if self.routes[choice[j].id]:intersects(self.routes[choice[i].id]) then 
                local arc = self.routes[choice[i].id]:getBranchArc(self.routes[choice[j].id], self.forbids)
                if arc then return arc end 
            end 
        end
    end 
end 

function Master:isInteger()
    local result = self:getResult() 
    for i=1,#result do
        if result[i] % 1 > 0.0001 and (1 - result[i] % 1) > 0.0001 then 
            return false
        end 
    end 
    return true
end 

function Master:getVarSum()
    local sum = 0
    for v,var in ipairs(self:getResult()) do
        sum = sum + var
    end 
    return sum 
end 

function Master:to_solution()
    local solu = Solution:new()
    for i, ir in ipairs{GetVariables(self.lp)} do
        if ir > 0.001 then
            solu:append(self.routes[i])
        end 
    end 
    return solu
end 

function Master:solveSubproblem() -- car type   vtp   carDuals[vtp]   vehicle[vtp].tc,fc,weight,volume
    unprocessed, useful = {Label:new({}, true)}, {}
    repeat
        local label = unprocessed[#unprocessed]
        useful[#useful+1] = label
        table.remove(unprocessed)
        
        for _,forbid in ipairs(self.forbids) do
            forbid:forbid(label) 
        end 
        
        for i=1,#nodes do
            if label.sign[i] < 1 then
                local new_label = label:extend(i) 
                if new_label and not new_label:isDominated() then 
                    for i=#unprocessed,1,-1 do --使用hashmap
                        if new_label.id == unprocessed[i].id and unprocessed[i]:isDominatedBy(new_label) then
                            table.remove(unprocessed, i)
                        end
                    end 
                    if new_label.active then
                        unprocessed[#unprocessed+1] = new_label
                    else
                        useful[#useful+1] = new_label
                    end 
                end 
            end
            ::continue::
        end
    until #unprocessed == 0
    
    --print('there are ', #useful, ' labels in useful')
    
    --local negative_routes = {}
    for i=2,#useful do 
        useful[i].cost = useful[i].cost + dis(useful[i].id, 0) - self.carDual
        --if useful[i].cost < -0.0001 then
            --negative_routes[#negative_routes+1] = useful[i]:to_route
        --end 
    end 
    
    table.sort(useful, function(a,b) return a.cost < b.cost end)
    if useful[2].cost < -0.0001 then 
        return useful[1]:to_route(), useful[2]:to_route() 
    else
        return useful[1]:to_route()
    end
    
    --return negative_routes
end 

function Master:updateUpbound()
    if self:getObj() < UpBound then 
        UpBound = self:getObj() 
        BestVehicles = self:getVarSum()
        solution = self:to_solution()
    end 
end 

BranchNode = {}
BranchNode.__index = BranchNode

function BranchNode:new(cRoutes, cForbids, vNumberCons)
    local self = {routes = cRoutes or Constructives.getBackForth(), forbids = cForbids or {}, vNumberCons = vNumberCons}
    setmetatable(self, BranchNode)
    return self
end 

function BranchNode:columnGeneration()
    require 'mobdebug'.off()
    local iter, master = 0
    repeat
        iter = iter + 1
        master = Master:new(self.routes, self.forbids, self.vNumberCons)
        if master:solve() ~= 0 then return nil end 
        master:setNodesDual()
        self.routes[#self.routes+1], self.routes[#self.routes+2] = master:solveSubproblem()
        --print(string.format('the LP relax obj = %02f and The min reduced cost = %02f', master:getObj(),self.routes[#self.routes].cost))
    until self.routes[#self.routes].cost > -0.1
    --print('Total iteration = ', iter)
    require 'mobdebug'.on()
    return master
end

function BranchNode:filter(cRoutes)
    if #self.forbids > 0 then 
        for i=#cRoutes,1,-1 do
            if self.forbids[#self.forbids]:isForbidden(cRoutes[i]) then
                table.remove(cRoutes, i)
            end 
        end 
    end
    return cRoutes
end

function BranchNode:branching(cRoutes, vNumberCons)
    vNumberCons = vNumberCons or self.vNumberCons    
    BranchNode:new(self:filter(cRoutes), DeepCopy(self.forbids), vNumberCons):solve()
end 

function BranchNode:solve()
    local master = self:columnGeneration() 
    if master then
        print(string.format('The LP relax objective value is %.2f and UpBound = %.2f', master:getObj(), UpBound))
        if master:isInteger() then
            master:updateUpbound()
        elseif master:getObj() - UpBound < -0.0001 then  
            local vehcile_number = master:getVarSum()
            
            if vehcile_number % 1 > 0.0001 and (1 - vehcile_number % 1) > 0.0001 then 
                
                master:solve(true)
                master:updateUpbound()
                
                print('Branching at vehicle number <= ', math.floor(vehcile_number))
                self:branching(DeepCopy(self.routes), {math.floor(vehcile_number), '<='})
                print('Branching at vehicle number >=', math.ceil(vehcile_number))
                self:branching(self.routes, {math.ceil(vehcile_number) , '>='})
            else
                local arc = master:getBranchArc()       
                master:solve(true)
                master:updateUpbound()
                if arc then    
                    print('Branching at 0 not arc = {', arc[1], ',', arc[2], '}')
                    self.forbids[#self.forbids+1] = (Forbid:new(arc, 0))
                    self:branching(DeepCopy(master.routes))
                    
                    print('Branching at 1 arc = {', arc[1], ',', arc[2], '}')
                    self.forbids[#self.forbids].ok = 1
                    self:branching(master.routes)
                end 
            end 
        end 
    end
end 

function main()
    nodes, Dis, Time, vehicle = VRPIO.read_solomon('R106', 25)
    preprocessing()
    nodes[0].dual = 0
    local starttime = os.clock()
    solution = {}
    BranchNode:new():solve()
    --solution:plot()
    print('The best objective value is ', UpBound, ' and vehicle number is ', BestVehicles)
    print('Total CPU time is ', os.clock() - starttime)
end

main()